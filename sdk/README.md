<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# sdk

```go
import "github.com/faciam-dev/gcfm/sdk"
```

## Index

- [Variables](<#variables>)
- [func UnifiedDiff\(a, b string\) string](<#UnifiedDiff>)
- [func WithTenantID\(ctx context.Context, tenantID string\) context.Context](<#WithTenantID>)
- [type ApplyOptions](<#ApplyOptions>)
- [type DBConfig](<#DBConfig>)
- [type DiffReport](<#DiffReport>)
  - [func CalculateDiff\(changes \[\]registry.Change\) DiffReport](<#CalculateDiff>)
- [type DisplayMeta](<#DisplayMeta>)
- [type DisplayOptions](<#DisplayOptions>)
- [type FieldDef](<#FieldDef>)
- [type FieldMeta](<#FieldMeta>)
- [type ScanResult](<#ScanResult>)
- [type Service](<#Service>)
  - [func New\(cfg ServiceConfig\) Service](<#New>)
- [type ServiceConfig](<#ServiceConfig>)
- [type Snapshot](<#Snapshot>)
- [type SnapshotClient](<#SnapshotClient>)
- [type TargetConfig](<#TargetConfig>)
- [type TargetConn](<#TargetConn>)
- [type TargetRegistry](<#TargetRegistry>)
  - [func NewTargetRegistry\(defaultConn TargetConn\) TargetRegistry](<#NewTargetRegistry>)
- [type TargetResolver](<#TargetResolver>)
  - [func TenantResolverFromPrefix\(prefix string\) TargetResolver](<#TenantResolverFromPrefix>)


## Variables

<a name="ErrNoTarget"></a>

```go
var ErrNoTarget = errors.New("no target database resolved")
```

<a name="ErrValidatorNotFound"></a>ErrValidatorNotFound is returned when a validator plugin cannot be found.

```go
var (
    ErrValidatorNotFound = errors.New("validator not found")
)
```

<a name="UnifiedDiff"></a>
## func UnifiedDiff

```go
func UnifiedDiff(a, b string) string
```

UnifiedDiff returns a unified diff string of two inputs.

<a name="WithTenantID"></a>
## func WithTenantID

```go
func WithTenantID(ctx context.Context, tenantID string) context.Context
```

WithTenantID attaches a tenant ID to the context.

<a name="ApplyOptions"></a>
## type ApplyOptions



```go
type ApplyOptions struct {
    // DryRun skips applying changes and only computes the diff.
    DryRun bool
    Actor  string
}
```

<a name="DBConfig"></a>
## type DBConfig

DBConfig specifies database connection parameters.

```go
type DBConfig struct {
    Driver      string // mysql|postgres|mongo
    DSN         string
    Schema      string
    TablePrefix string
}
```

<a name="DiffReport"></a>
## type DiffReport



```go
type DiffReport struct {
    // Added is the number of newly created fields.
    Added int
    // Deleted is the number of removed fields.
    Deleted int
    // Updated is the number of modified fields.
    Updated int
}
```

<a name="CalculateDiff"></a>
### func CalculateDiff

```go
func CalculateDiff(changes []registry.Change) DiffReport
```

CalculateDiff returns counts of added, deleted and updated changes.

<a name="DisplayMeta"></a>
## type DisplayMeta



```go
type DisplayMeta = registry.DisplayMeta
```

<a name="DisplayOptions"></a>
## type DisplayOptions



```go
type DisplayOptions = registry.DisplayOption
```

<a name="FieldDef"></a>
## type FieldDef



```go
type FieldDef = registry.FieldMeta
```

<a name="FieldMeta"></a>
## type FieldMeta



```go
type FieldMeta = registry.FieldMeta
```

<a name="ScanResult"></a>
## type ScanResult



```go
type ScanResult = schema.ScanResult
```

<a name="Service"></a>
## type Service

Service exposes high level operations for custom field registry. Service provides database operations for custom field registry.

```go
type Service interface {
    // Scan reads schema information from the database.
    Scan(ctx context.Context, cfg DBConfig) ([]registry.FieldMeta, error)
    // Export dumps registry metadata as YAML.
    Export(ctx context.Context, cfg DBConfig) ([]byte, error)
    // Apply updates the registry based on the provided YAML.
    Apply(ctx context.Context, cfg DBConfig, yaml []byte, opts ApplyOptions) (DiffReport, error)
    // MigrateRegistry upgrades or downgrades the registry schema.
    MigrateRegistry(ctx context.Context, cfg DBConfig, target int) error
    // RegistryVersion returns the current registry schema version.
    RegistryVersion(ctx context.Context, cfg DBConfig) (int, error)
    // ListCustomFields returns custom field metadata.
    ListCustomFields(ctx context.Context, dbID int64, table string) ([]registry.FieldMeta, error)
    // CreateCustomField inserts a new field into the registry.
    CreateCustomField(ctx context.Context, fm registry.FieldMeta) error
    // UpdateCustomField modifies an existing field.
    UpdateCustomField(ctx context.Context, fm registry.FieldMeta) error
    // DeleteCustomField removes a field from the registry.
    DeleteCustomField(ctx context.Context, table, column string) error
}
```

<details><summary>Example (Multi Target)</summary>
<p>



```go
package main

import (
	"context"
	"database/sql"
	"os"

	"github.com/faciam-dev/gcfm/sdk"
)

func main() {
	meta, _ := sql.Open("postgres", os.Getenv("META_DSN"))
	dbA, _ := sql.Open("mysql", os.Getenv("TENANT_A_DSN"))
	dbB, _ := sql.Open("mysql", os.Getenv("TENANT_B_DSN"))

	svc := sdk.New(sdk.ServiceConfig{
		DB:         dbA,
		Driver:     "mysql",
		MetaDB:     meta,
		MetaDriver: "postgres",
		MetaSchema: "gcfm_meta",
		Targets: []sdk.TargetConfig{
			{Key: "tenant:A", DB: dbA, Driver: "mysql", Schema: ""},
			{Key: "tenant:B", DB: dbB, Driver: "mysql", Schema: ""},
		},
		TargetResolver: sdk.TenantResolverFromPrefix("tenant:"),
	})

	ctx := sdk.WithTenantID(context.Background(), "A")
	_, _ = svc.ListCustomFields(ctx, 1, "posts")
}
```

</p>
</details>

<details><summary>Example (Quickstart)</summary>
<p>



```go
package main

import (
	"context"
	"log"

	"github.com/faciam-dev/gcfm/sdk"
)

func main() {
	ctx := context.Background()
	svc := sdk.New(sdk.ServiceConfig{})
	cfg := sdk.DBConfig{
		DSN:    "mysql://user:pass@tcp(localhost:3306)/app",
		Schema: "app",
	}

	yaml, err := svc.Export(ctx, cfg)
	if err != nil {
		log.Fatal(err)
	}

	if _, err := svc.Apply(ctx, cfg, yaml, sdk.ApplyOptions{DryRun: true}); err != nil {
		log.Fatal(err)
	}

	if err := svc.MigrateRegistry(ctx, cfg, 0); err != nil {
		log.Fatal(err)
	}
}
```

</p>
</details>

<details><summary>Example (Separate Meta DB)</summary>
<p>



```go
package main

import (
	"database/sql"
	"os"

	"github.com/faciam-dev/gcfm/sdk"
)

func main() {
	meta, _ := sql.Open("postgres", os.Getenv("META_DSN"))
	target, _ := sql.Open("mysql", os.Getenv("TARGET_DSN"))
	_ = sdk.New(sdk.ServiceConfig{
		DB:         target,
		Driver:     "mysql",
		MetaDB:     meta,
		MetaDriver: "postgres",
		MetaSchema: "gcfm_meta",
	})
}
```

</p>
</details>

<a name="New"></a>
### func New

```go
func New(cfg ServiceConfig) Service
```

New returns a Service initialized with the given configuration. Validator plugins under PluginDir are loaded automatically.

<a name="ServiceConfig"></a>
## type ServiceConfig

ServiceConfig holds optional configuration for Service.

DB, Driver and Schema specify the default connection to the monitored database. If the Meta\* fields are left nil or empty, they inherit these default values.

```go
type ServiceConfig struct {
    Logger          *zap.SugaredLogger
    PluginDir       string
    PluginPublicKey string
    PluginEnabled   *bool
    Recorder        *audit.Recorder
    Notifier        notifier.Broker

    // Default connection for monitored databases. Kept for backward
    // compatibility.
    DB     *sql.DB
    Driver string
    Schema string

    // Optional separate connection for metadata storage. When omitted,
    // the above DB/Driver/Schema values are used.
    MetaDB     *sql.DB
    MetaDriver string
    MetaSchema string

    // Target databases for monitoring. If empty, the default DB/Driver/
    // Schema fields represent the only target.
    Targets []TargetConfig

    // TargetResolver selects a target based on the request context. When
    // nil, operations fall back to the default target.
    TargetResolver TargetResolver
}
```

<a name="Snapshot"></a>
## type Snapshot

Snapshot describes a stored registry snapshot.

```go
type Snapshot struct {
    ID      int64
    Semver  string
    TakenAt time.Time
    Author  string
}
```

<a name="SnapshotClient"></a>
## type SnapshotClient

SnapshotClient provides snapshot operations.

```go
type SnapshotClient interface {
    List(ctx context.Context, tenant string) ([]Snapshot, error)
    Create(ctx context.Context, tenant, bump, msg string) (Snapshot, error)
    Apply(ctx context.Context, tenant, ver string) error
    Diff(ctx context.Context, tenant, from, to string) (string, error)
}
```

<a name="TargetConfig"></a>
## type TargetConfig

TargetConfig defines an individual monitored database.

```go
type TargetConfig struct {
    Key    string // unique identifier like "tenant:foo" or "db:orders"
    DB     *sql.DB
    Driver string
    Schema string
    Labels []string // optional tags such as "tenant:foo" or "region:tokyo"
}
```

<a name="TargetConn"></a>
## type TargetConn

TargetConn represents a monitored database connection.

```go
type TargetConn struct {
    DB     *sql.DB
    Driver string
    Schema string
    Labels map[string]struct{}
}
```

<a name="TargetRegistry"></a>
## type TargetRegistry

TargetRegistry manages monitored database connections.

```go
type TargetRegistry interface {
    Register(cfg TargetConfig) error
    Get(key string) (TargetConn, bool)
    Default() (TargetConn, bool)
    Keys() []string
    ForEach(func(key string, t TargetConn) error) error
}
```

<a name="NewTargetRegistry"></a>
### func NewTargetRegistry

```go
func NewTargetRegistry(defaultConn TargetConn) TargetRegistry
```

NewTargetRegistry creates a registry initialized with the default connection.

<a name="TargetResolver"></a>
## type TargetResolver

TargetResolver chooses a target key from the request context. It returns the key and true on success.

```go
type TargetResolver func(ctx context.Context) (key string, ok bool)
```

<a name="TenantResolverFromPrefix"></a>
### func TenantResolverFromPrefix

```go
func TenantResolverFromPrefix(prefix string) TargetResolver
```

TenantResolverFromPrefix returns a TargetResolver that looks up tenant ID with given prefix.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
